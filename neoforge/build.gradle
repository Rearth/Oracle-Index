import java.util.zip.ZipEntry
import java.util.zip.ZipInputStream
import java.util.zip.ZipOutputStream

plugins {
    id 'com.github.johnrengelman.shadow'
}

architectury {
    platformSetupLoomIde()
    neoForge()
}

loom {
    accessWidenerPath.set(project(":common").loom.accessWidenerPath)
}

configurations {
    common {
        canBeResolved = true
        canBeConsumed = false
    }
    compileClasspath.extendsFrom common
    runtimeClasspath.extendsFrom common
    developmentNeoForge.extendsFrom common

    // Files in this configuration will be bundled into your mod using the Shadow plugin.
    // Don't use the `shadow` configuration from the plugin itself as it's meant for excluding files.
    shadowBundle {
        canBeResolved = true
        canBeConsumed = false
    }
}

repositories {
    maven {
        name = 'NeoForged'
        url = 'https://maven.neoforged.net/releases'
    }
}

dependencies {
    neoForge "net.neoforged:neoforge:$rootProject.neoforge_version"

    // Architectury API. This is optional, and you can comment it out if you don't need it.
    modImplementation "dev.architectury:architectury-neoforge:$rootProject.architectury_api_version"

    common(project(path: ':common', configuration: 'namedElements')) { transitive false }
    shadowBundle project(path: ':common', configuration: 'transformProductionNeoForge')

    // owo lib
    modImplementation "io.wispforest:owo-lib-neoforge:0.12.15-beta.9+1.21"
    forgeRuntimeLibrary(include(api("io.wispforest:endec:0.1.8")))
    forgeRuntimeLibrary(include(api("io.wispforest.endec:netty:0.1.4")))
    forgeRuntimeLibrary(include(api("io.wispforest.endec:gson:0.1.5")))
    forgeRuntimeLibrary(include(api("io.wispforest.endec:jankson:0.1.5")))
    forgeRuntimeLibrary(include(api("blue.endless:jankson:1.2.2")))

    // included libs
    forgeRuntimeLibrary(include(api("dev.langchain4j:langchain4j:1.0.0")))
    forgeRuntimeLibrary(include(api("dev.langchain4j:langchain4j-core:1.0.0")))
    forgeRuntimeLibrary(include(api("dev.langchain4j:langchain4j-embeddings:1.0.0-beta5")))
    forgeRuntimeLibrary(include(api("dev.langchain4j:langchain4j-embeddings-all-minilm-l6-v2-q:1.0.0-beta5")))
    forgeRuntimeLibrary(include(api("ai.djl:api:0.31.1")))
    forgeRuntimeLibrary(include(api("ai.djl.huggingface:tokenizers:0.31.1")))
    forgeRuntimeLibrary(include(api("org.apache.opennlp:opennlp-tools:2.5.4")))
    forgeRuntimeLibrary(include(api("com.microsoft.onnxruntime:onnxruntime:1.20.0")))

    forgeRuntimeLibrary(include(api("net.objecthunter:exp4j:0.4.8")))

    forgeRuntimeLibrary(include(api("org.jsoup:jsoup:1.17.2")))
}

processResources {
    inputs.property 'version', project.version

    filesMatching('META-INF/neoforge.mods.toml') {
        expand version: project.version
    }
}

shadowJar {
    configurations = [project.configurations.shadowBundle]
    archiveClassifier = 'dev-shadow'
}

// because the stupid microsoft onnx package contains 50MB of unnecessary pdb files, we re-assemble the entire dist jar, and strip out those files
task cleanRemappedJar {

    doLast {
        File original = remapJar.archiveFile.get().asFile
        File temp = new File(original.parentFile, original.name + ".tmp")

        // Open streams for reading the old jar and writing the new one
        ZipInputStream zis = new ZipInputStream(new FileInputStream(original))
        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(temp))

        ZipEntry entry
        while ((entry = zis.nextEntry) != null) {
            String name = entry.name

            // Handle nested JARs in META-INF/jars/
            if (name.startsWith("META-INF/jars/")) {
                // Unzip the nested jar into memory, filter entries, and re-zip
                ByteArrayOutputStream baos = new ByteArrayOutputStream()
                ZipInputStream nestedIn  = new ZipInputStream(zis)
                ZipOutputStream nestedOut = new ZipOutputStream(baos)

                ZipEntry nestedEntry
                while ((nestedEntry = nestedIn.nextEntry) != null) {
                    String neName = nestedEntry.name
                    // skip pdb / macos debugger files
                    // skip osx and linux native support
                    if (!neName.endsWith(".pdb") && !neName.contains(".dSYM/") && !neName.contains("osx-") && !neName.contains("linux-")) {
                        nestedOut.putNextEntry(new ZipEntry(neName))
                        nestedIn.transferTo(nestedOut)
                        nestedOut.closeEntry()
                    }
                }
                nestedOut.close()
                // Write the filtered nested-jar back into the outer jar
                ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray())
                zos.putNextEntry(new ZipEntry(name))
                bais.transferTo(zos)
                zos.closeEntry()

                // Otherwise, skip any top-level .pdb or anything under .dSYM
            } else {
                zos.putNextEntry(new ZipEntry(name))
                zis.transferTo(zos)
                zos.closeEntry()
            }
            // else — we’ve hit a .pdb or .dSYM path, so we simply don’t copy it
        }

        // close everything
        zis.close()
        zos.close()

        // Replace the original jar
        original.delete()
        temp.renameTo(original)
    }
}

task xplatJar {

    doLast {
        File original = remapJar.archiveFile.get().asFile
        File temp = new File(original.parentFile, original.name.replace(".jar", "-xplat.jar"))

        // Open streams for reading the old jar and writing the new one
        ZipInputStream zis = new ZipInputStream(new FileInputStream(original))
        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(temp))

        ZipEntry entry
        while ((entry = zis.nextEntry) != null) {
            String name = entry.name

            // Handle nested JARs in META-INF/jars/
            if (name.startsWith("META-INF/jars/")) {
                // Unzip the nested jar into memory, filter entries, and re-zip
                ByteArrayOutputStream baos = new ByteArrayOutputStream()
                ZipInputStream nestedIn  = new ZipInputStream(zis)
                ZipOutputStream nestedOut = new ZipOutputStream(baos)

                ZipEntry nestedEntry
                while ((nestedEntry = nestedIn.nextEntry) != null) {
                    String neName = nestedEntry.name
                    // skip pdb / macos debugger files
                    // skip osx and linux native support
                    if (!neName.endsWith(".pdb") && !neName.contains(".dSYM/")) {
                        nestedOut.putNextEntry(new ZipEntry(neName))
                        nestedIn.transferTo(nestedOut)
                        nestedOut.closeEntry()
                    }
                }
                nestedOut.close()
                // Write the filtered nested-jar back into the outer jar
                ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray())
                zos.putNextEntry(new ZipEntry(name))
                bais.transferTo(zos)
                zos.closeEntry()

                // Otherwise, skip any top-level .pdb or anything under .dSYM
            } else {
                zos.putNextEntry(new ZipEntry(name))
                zis.transferTo(zos)
                zos.closeEntry()
            }
            // else — we’ve hit a .pdb or .dSYM path, so we simply don’t copy it
        }

        // close everything
        zis.close()
        zos.close()
    }
}

remapJar.finalizedBy(cleanRemappedJar)
remapJar.finalizedBy(xplatJar)

remapJar {
    inputFile.set shadowJar.archiveFile
}

publishMods {
    file = remapJar.archiveFile
    changelog = file("../CHANGELOG.md").getText()
    type = BETA
    modLoaders.add("neoforge")

    modrinth {
        accessToken = providers.environmentVariable("MODRINTH_API_KEY")
        projectId = "J8MMsNrL"
        minecraftVersions.add("1.21.1")

        requires("owo-lib")
        requires("architectury-api")

        announcementTitle = "Neoforge Version on Modrinth"
    }

    curseforge {
        accessToken = providers.environmentVariable("CURSEFORGE_API_KEY")
        projectId = "1206582"
        minecraftVersions.add("1.21.1")

        requires("owo-lib")
        requires("architectury-api")

        javaVersions.add(JavaVersion.VERSION_21)
        clientRequired = true
        serverRequired = false

        projectSlug = "oritech"
        announcementTitle = "Neoforge Version on CurseForge"
    }
}
